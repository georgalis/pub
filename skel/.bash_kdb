#!/bin/bash

# kdb mvp 5beb60d0 stylepro

# Copyright (C) 2015-2018 George Georgalis <george@galis.org>
# All rights reserved. No use or redistribution allowed.
#
# Including but not limited to algorithms, format and procedures.
# Managed data remains under respective copyright of the owners.

#ks knowledge motive curation query cache pointer db
#kr 59dab11b sub kdb idk tools
#kr 59d94184 KDB schema, LQL

# @@ ## ### ##### ######## Basic #####
# ks subj         new k4
# k {nx|xs|xss}   edit k4 (default 0)
# ka {nx|xs|xss}  aspell (default 0)
# kj regex        k4db regex to ^pool
#,kjt tag         k4db tag to ^pool
# kl              list pool by acquisition
# klr             list pool by reverse acquisition
# kt              list pool by modification
# ktr             list pool by reverse modification
# krst {args}     reset ^pool, iff args then kj args

# @@ ## ### ##### ######## Refine #####
# kg regex      grep regex from ^pool
# kv regex      grep -v regex from ^pool
# knx           make ptrnx and uidln from ^pool ptrid
#,ktnull {adj}  display nulltime, or adjust
#,ktlast {adj}  display lasttime, or adjust
#,kr {format}   display range (default +%Y%m%d_%H%M%S)

# @@ ## ### ##### ######## Pools #####
# kfp           find pools
#,kp regex      k4db regex into sub ^pool
#,kpt regex     tags regex into sub ^pool
#,kz            combine ^pool with enclosing ^pool
#,kw {name}     name ^0 (default xs) and switch ^pool to ^0

# @@ ## ### ##### ######## Extract #####
# kxl       {nx|xs|xss}    extract k4 link(s) default ^pool
#,khist     {number}    number lines of command history
# kh        {nx|xs|xss}    k4 head (default 0)
#,khx regex {nx|xs|xss}    k4 headx (default k4_view)
# kc        {nx|xs|xss}    k4 cat (default 0)
#,kcs       {nx|xs|xss}    k4 less (default 0)
#,km        {nx|xs|xss}    k4 markdown (default 0)
# kjq regex             quiet beckground k4db regex to ^pool
#,kjtq regex            quiet background tags regex to ^pool
# k_ {days}             k4 mod since days to ^pool
# k__ {hours}           k4 mod since hours to ^pool

# @@ ## ### ##### ######## Edge #####
#,ke  depth {nx|xs|xss}    k4 edge walk depth (diagram?)
#,kel depth {nx|xs|xss}    k4 link walk depth
#,kep depth {nx|xs|xss}    k4 super walk depth
#,ker depth {nx|xs|xss}    k4 related walk depth

#,regex:K kz       combine ^pool with enclosing ^pool
#,:K k4_p regex1
#,regex1:K k4_p regex2
#,regex1/regex2:K k4_p regex3
#,:regex2/regex3:K regex4
#,::regex3/regex4:K regex5
#,:::regex4/regex5:K k4_z            combine pool
#,::regex3/regex4:K k4_fp            find pools
#,regex1
#,regex2
#,::regex3/regex4:K sp poolpath   switch pool
#,::regex3/regex4:K z
#,:regex2/regex3:K z
#,regex1/regex2:K z
#,regex1:K z
#,:K p regex

# port to lua
[ "$0" = "-bash" ] || { echo "Bash only..." >&2  ; return 1 ; exit 1 ;}

# Translations
k%s%j%t%l%p%r () { echo "khx '^%k(s|j|t|p|r|l|)\ ' $@" ;}

k4db_fk4 () { #:- find kdb files from k4db
        # future standard will be .*/[:alnum:]*_/_[:alnum:].kdb
        #                         .*/{offset}_/_{epoch}.kdb
    $k4db_logstd "find ${k4db} ${since} -regex '.*_/.*' -prune -type f -name '*.kdb'"
            find ${k4db} ${since} -regex '.*_/.*' -prune -type f -name '*.kdb'
    } # k4db_fk4

kfp () { # find pool
    find $k4db/$k4_pool -name =\* | sed 's/.*0//' | sort -d | column
    echo $k4_pool | sed 's/.*0/0/'
    } # kfp

# ekc () {
# local epoch($SHLVL)="$1"
# set $(eid)
# [ "$epoch($SHLVL)" ] || epoch[$SHLVL]="$1"
#
# local epoch="$1"
# k4db="$k4db" bash --noprofile -c ". $k4db/include-bash && PS1='$k4db/3/c/$SHLVL'"
# return $?
# }

cat >>/dev/null<<EOF
 export k3db="$k4db/3"
 export k4db0="$(cd ~dot0 ; pwd -P)"
 export k4dbc="$(cd ~dotc ; pwd -P)"
 export k5db="$k4db/5"
 export kcdb="/Users/dotc"
 export kcdb="/Users/dotc"
EOF

k4_help () { #:o kdb function descriptions
cat <<EOF
Nomenclature:
 k{name}     user shell function
 k4_{name}   function on elements
 k4db_{name} function on entire db

${FUNCNAME}_1 : Major commands
${FUNCNAME}_2 : Primitive functions
${FUNCNAME}_3 : Unit operations
${FUNCNAME}_4 : Development
${FUNCNAME}_5 : Environment
${FUNCNAME}_6 : GLOSSARY
${FUNCNAME}_7 : PATHs
${FUNCNAME}_8 : K4 file format
${FUNCNAME}_9 : All of the above
EOF
}

cat >/dev/null <<'EOF'
# support multiple db, pub, pvt,
# kz move directory to alternate
# every kdb file should have a valid %kp , or identified as orphan

 # pub.dot4.space
 # pvt.dot4.space/id
 # grp.dot4.space/id
 # idb.dot4.space/3/{sess}/{tag|nx|xs|}/{nx|tag|xs|xss}
 # idb.dot4.space/0/epoch/{tag}
 # idb.dot4.space/5/xs
 # idb.dot4.space/5/xss

EOF

k4_help_1 () {
local c
cat <<EOF
	= Major commands (#:o)
$(c='#:o' ; grep -Ev '^(#|\$|	)' "$k4db_fun" | grep "$c" | sed -e "s/ ().*$c/	:/"   -e "s/$c/ :/")
EOF
}

k4_help_2 () {
local c
cat <<EOF
	= Primitive functions (#::)
$(c='#::' ; grep -Ev '^(#|\$|	)' "$k4db_fun" | grep "$c" | sed -e "s/ ().*$c/	:/"   -e "s/$c/ :/")
EOF
}

k4_help_3 () {
local c
cat <<EOF
	= Unit operations (#:>)
$(c='#:>' ; grep -Ev '^(#|\$|	)' "$k4db_fun" | grep "$c" | sed -e "s/ ().*$c/	:/"   -e "s/$c/ :/")
EOF
}

k4_help_4 () {
local c
cat <<EOF
	= Development (#:-)
$(c='#:-' ; grep -Ev '^(#|\$|	)' "$k4db_fun" | grep "$c" | sed -e "s/ ().*$c/	:/"   -e "s/$c/ :/")
EOF
}

k4_help_5 () {
cat <<EOF
	= Environment
$(grep ^export "$k4db_fun")
EOF
}

k4_help_6 () {
cat <<EOF
	= GLOSSARY
 k4    kdb file and/or path
 k4db  set of k4
 c     query k4db records
 k     act on specific c result
EOF
}

k4_help_7 () {
cat <<EOF
	= PATHs
 \$k4db/3/c/1/ cumulative logs and ptr
 \$k4db/3/c/2/ performance indices

 \$k4db/3/c/0/ptrid/\$uid
	= FILEPATHs
 \$k4db/3/c/: misc tmp files
X\$k4db/3/c/0/{ep}/0.log: primary search log
X\$k4db/3/c/0/{ep}/1.cmd: invocation command
 \$k4db/3/c/0/uidln/\$uid : uid ([:xdigit:]]\{16\}) named link to k4 file
 \$k4db/3/c/0/ptrid/\$uid : ptr data (2 lines: k4 path and uid) of k4 uid ([:xdigit:]]\{16\})
 \$k4db/3/c/0/ptrnx/\$nx : 0x numbered link to ptrid/\$uid
 \$k4db/3/c/0/tx.\$FUNCNAME}.0 : benchmark start time
 \$k4db/3/c/0/tx.\$FUNCNAME}.1 : benchmark stop time
X\$k4db/3/c/0/{ep}/xss/'[[:xdigit:]]\{24\}$': primary search result (^k4 %k*)
 \$k4db/3/c/1/\$(date "+%Y%m%d")/ptrid/: ptrid for abandoned results
 \$k4db/3/c/1/xss/{xss}: secondary search result {xss} link to 3/c/0/*/xss/[[:xdigit:]]\{24\} (^k4 %k*)
X\$k4db/3/c/1/{kx}/{xss}: secondary search, xss links to 3/c/0/*/xss/[[:xdigit:]]\{24\} (^k4 %ks %kx)
 \$k4db/3/c/1/secondary.log: secondary search log
 \$k4db/4/: display search index, epoch bundle (local cache)
 \$k4db/4/0/0: last (^k4 %ks %kx)
 \$k4db/4/0/1: prior (^k4 %ks %kx)
 \$k4db/4/0/2: prior (^k4 %ks %kx)
 \$k4db/4/0/3: prior (^k4 %ks %kx)
 \$k4db/4/0/4: prior (^k4 %ks %kx)
 \$k4db/4/0/5: prior (^k4 %ks %kx)
 \$k4db/4/0/6: prior (^k4 %ks %kx)
 \$k4db/4/0/7: prior (^k4 %ks %kx)
?\$k4db/4/0/{epoch}: cumulative prior display, expires (^k4 %ks %kx)
 \$k4db/4/{epoch}/xss/{xss}: layer {epoch} search files, cumulative log, from 3/c/1/* on epoch reset
 \$k4db/4/{epoch}/nx/{nx}: layer {epoch} search files, cumulative log, from 3/c/1/* on epoch reset
X\$k4db/4/{epoch}/kx/{kx}: layer {epoch} search files, cumulative log, from 3/c/1/* on epoch reset
 \$k4db/4/{epoch}/0.log: cumulative log, from 3/c/1/secondary.log on epoch reset
 \$k4db/5/: kdb master (best available)
 \$k4db/5/{k4db_np}/40000000.kdb (k4 files)
 \$k4db/6
 \$k4db/tag.tbl
 \$k4db/include-bash
 \$k4db/.git
 \$k4db/design
 \$k4db/dev
 \$k4db/bin
 \$k4db/man
 \$k4db/   ./4/{tag} : list of dot3
 \$k4db/   ./3/{[:xdigit:]*/}/ : cache index of
EOF
}

k4_help_8 () {
grep '^	' "$k4db_fun"
cat <<'EOF'
EOF
}

k4_help_9 () {
k4_help_1 ; echo
k4_help_2 ; echo
k4_help_3 ; echo
k4_help_4 ; echo
k4_help_5 ; echo
k4_help_6 ; echo
k4_help_7 ; echo
k4_help_8
}


#:o
#::
#:>
#:>>
#:-
#:=

#=
#o
#+
#-
#:.
#:+
#:^
#:<
#<:
#:%
#o-
#.:
#o:
#-:
#=:
#+:

# @@ exclude ./skel and ./mkinst from result
# find . \( -path ./skel -o -path ./mkinst \) \! -prune -o -type f

# @@ example string operations, or groke the man
#   x="aaa/bbb/ccc"
#  y="/aaa/bbb/ccc/"
#
#
#echo 1: ${x##*/}       2: ${x#*/}        3: ${x##/*}       4: ${x#/*}
#     1: ccc            2: bbb/ccc        3: aaa/bbb/ccc    4: aaa/bbb/ccc
#
#echo 5: ${x%%*/}       6: ${x%*/}        7: ${x%%/*}       8: ${x%/*}
#     5: aaa/bbb/ccc    6: aaa/bbb/ccc    7: aaa            8: aaa/bbb
#
#echo 9: ${y##*/}       a: ${y#*/}        b: ${y##/*}       c: ${y#/*}
#     9:                a: aaa/bbb/ccc/   b:                c: aaa/bbb/ccc/
#
#echo d: ${y%%*/}       e: ${y%*/}        f: ${y%%/*}       g: ${y%/*}
#     d:                e: /aaa/bbb/ccc   f:                g: /aaa/bbb/ccc
#
#
#echo 1: ${x%%*b}       2: ${x%*b}        3: ${x%%b*}       4: ${x%b*}
#     1: aaa/bbb/ccc    2: aaa/bbb/ccc    3: aaa/           4: aaa/bb
#
#echo 5: ${x##*b}       6: ${x#*b}        7: ${x##b*}       8: ${x#b*}
#     5: /ccc           6: bb/ccc         7: aaa/bbb/ccc    8: aaa/bbb/ccc
#
#echo 9: ${y##*b}       a: ${y#*b}        b: ${y##b*}       c: ${y#b*}
#     9: /ccc/          a: bb/ccc/        b: /aaa/bbb/ccc/  c: /aaa/bbb/ccc/
#
#echo d: ${y%%*b}       e: ${y%*b}        f: ${y%%b*}       g: ${y%b*}
#     d: /aaa/bbb/ccc/  e: /aaa/bbb/ccc/  f: /aaa/          g: /aaa/bb
#
#  Substring Expansion
#     ${parameter:offset}
#     ${parameter:offset:length}
#  Parameter Length
#     ${#parameter}
# meta parameters to display

stdwrn () { echo "^^^ $* ^^^" 1>&2 ;} #:> return args to stderr as warning
stderr () { echo ">>> $* <<<" 1>&2 ;} #:> return args to stderr as error

[ -n "$k4db" ] || { stderr '$k4db not set!' ; return 1 ; exit 1 ;}
[ -d "$k4db" ] || { stderr '$k4db not a directory!' ; return 1 ; exit 1 ;}
[ -x "$(which $EDITOR)" ] || { stderr '$EDITOR not set' ; return 1 ; exit 1 ;}
[ -x "$(which tai64n)" ] || { stderr 'tai64n not in $PATH' ; return 1 ; exit 1 ;}

k4db_logstd () { echo "$*"         | tai64n >>"${k4db}/${k4_pool}/log" ;} #:> log args
logwrn () { echo "^^^ $* ^^^" | tai64n >>"${k4db}/${k4_pool}/log" ;} #:> log args as warning
logerr () { echo ">>> $* <<<" | tai64n >>"${k4db}/${k4_pool}/log" ;} #:> log args as error
stdstd () { [ "$*" ] && { $k4db_logstd "$*" ; echo   "$*" ; return 0 ;} || true ;} #:> if args not null, k4db_logstd args and return args return 0
chkwrn () { [ "$*" ] && { logwrn "$*" ; stdwrn "$*" ; return 0 ;} || true ;} #:> if args not null, logwrn args and stderr args return 0
chkerr () { [ "$*" ] && { logerr "$*" ; stderr "$*" ; return 1 ;} || true ;} #:> if args not null, logerr args and stderr args return 1

kwds () { #:> translate stdin into unique keywords stdout
    local w
    sed -E -e '/^%k(d|r|r|p|nd|nx|no|i|e|v|a|z)(_|\ |$)/d' \
           -e '/^[[:xdigit:]]\{8\}/d' -e 's/http.*( |$)//' \
    | tr -c '[:alnum:]_-=#' ' ' | tr ' ' '\n' \
    | sed -e '/^...$/d' -e '/^..$/d' -e '/^.$/d' -e '/^$/d' \
          -e '/^[[:xdigit:]]\{8\}/d' -e '/^_[[:xdigit:]]\{8\}/d' \
    | aspell -l en munch \
    | tr ' ' '\n' \
    | sed -e 's:/.*::' -e '/^...$/d' -e '/^..$/d' -e '/^.$/d' -e '/^$/d' \
    | sort --ignore-case --unique \
    | while read w ; do { grep -iEq "(^|\ )${w}(\ |$)" "$k4db_ntag" || echo "$w" ;} ; done \
    | while read w ; do { grep -iE  "(^|\ )${w}(\ |$)" "$k4db_tags" || echo "$w" ;} | awk '{print $1}' ; done \
    } # kwds
#   | uniq \
#   | aspell -l en expand \
#   | aspell -l en munch-list keep multi \
#| tee "$k4db/f/pipeline1" \


k4db_np () { #:: read seed on stdin, determine first empty directory path of [arg1]/{seed}
#. include-bash && xssdaysec | k4db_np f 1/6 3/7 2/18
#f/5/b/9/b/d07b308d15b4 5b9b 5b9bd07b 308d15b4 ptio 20180914 08:14:57:1536938097 1/6 3/7 2/18
    local new pass line="$(head -n1)" prefix="$1"
    [ -d "$prefix" -a -w "$prefix" ] || { chkerr "prefix=$prefix not a writeable directory." ; return 1 ;}
    shift
    pass="$*"
    set $line
    seed=$1
    new="/$1"
    shift
    while [ -d "$(dirname "$prefix/$new")" ] ; do
        new="$(echo "$new" | sed -e 's:.*/.:&/:' -e 's://$:/+:' )"
        done
    span="${new##*/}"
    epoch="$( echo ${new%/*} | sed -e 's:/::g')"
    gpw="$( gpw 1 $(( ${#epoch} * ${#epoch} / 18 + 4 )) )"
    epoch="$( printf '%s' "$( echo ${new%/*} | sed 's:/::g')")"
    k4id="${epoch} $(echo ${seed} | sed -e 's/[[:xdigit:]]\{8\}/& /')"
    echo ${prefix}${new} $k4id $gpw $* $pass
    } # k3db_np

k4db_gk () { #:> generate a k4db file, return: directory file metadata
    local ks="$*"
    set $(xssdaysec | k4db_np "$k4db" ) #... creates nothing
    #/Users/geo/dot4/5/b/a/1/3/0a2_241f46bc 5ba13 5ba130a2 _241f46bc grifi 20180918 10:06:32:1537290392 xyz
    local d="$1"_ # novel path
    local epoch="$2"
    local k4="_${epoch}.kdb"
    local sp="$(basename $1)" # span
    local xs="$3"
    local ss="$4" # second xs (60ths in 0x)
    local v="$(dc -e "$(xs|xs2s) 2 /   $(xs|xs2s) v  + p" \
        | awk '{printf "%08x\n",$1}')" # default k4 value
    local i="$(printf '%x' "$(( $(date '+%s') + 86400 * 57 ))" )" # default review, 57 days from now
    local il="$(echo "$i" | xs2tai | tai64nlocal | sed 's/[.|][0]*$//')" # review as natural date
    local e="$(printf '%x' "$(( $(date '+%s') - 86400 * 18 ))" )" # default event begin, 18 days prior from now
    local z="$(xs)" # default event end, now
    local knd=$(nevernowd)
    local knx=$(nevernowx)
    local kno=$(nevernowo)
    shift
    local km="$*"
    mkdir -p "$d/$epoch"
    touch "$d/$epoch/index.md"
    cat >>$d/${k4}<<EOF
%ks $ks
%kj motive
%kt 
%kl_$xs $ss self # linked thread (named)
%kr_$xs $ss self # related named (progen)
%kp_$xs $ss self # super named (orphan)
%knd $knd
%knx $knx
%kno $kno
%km $km
%kd_$epoch/index.md
%kv $v # value
%ki $i # review $il
%ke $e # event begin
%kz $z # event end
EOF
    printf "\n\n" >>$d/${k4}
    touch -t "$(date -r 0x"$v" +%Y%m%d%H%M.%S)" $d/${k4},kv
    echo "$d $k4 $km"
	#%ku http://domain.tld/ related url  # related named url
	#%ko george@galis.org # owner
	#%kv 40000000 # value [:xdigit:]{8}
	#%ka 00000000 # access (0x count)
    } # k4db_gk

kll () { kl "$k4_topic" $@ ;} #:: show results sorted by creation time (long, $k4_topic)
kl () { #:: show results sorted by creation time
    local ex="$1" # additional optional k4 regex to display
    local uidlnd="$k4db/$k4_pool/uidln" ptrnxd="$k4db/$k4_pool/ptrnx"
    local xs nxp uidln ptrid
    k4db_hl '\'
    xssdaysec >$k4db/$k4_pool/tx.${FUNCNAME}.0
    knx # adds a second with pool of 200...
    ls "$uidlnd" | while read uidln ; do
        nxp=$(grep --files-with-matches "$uidln" "$ptrnxd"/* | head -n1 )
         printf '%- 3s ' "${nxp##*/}"
         xs="${uidln::8}"
         echo -n "$xs "
         k4db_headx '^%ks ' "$uidlnd/$uidln" | head -n1
         [ "$ex" ] && k4db_headx "$ex" "$uidlnd/$uidln" \
            | k4db_headx_filter \
            | awk -v xs="$xs" '{printf "%12s %s\n","",$0}'
        done | $k4_unlong
    k4db_hl '/'
    xssdaysec >$k4db/$k4_pool/tx.${FUNCNAME}.1
    {
      k4db_linkcount ": $FUNCNAME $@ {sort xs} : "
      k4db_xss_ddiff $k4db/$k4_pool/tx.${FUNCNAME} seconds ;} | $k4_unlong
    } # kl

klrl () { klr "^%k(m|t|j) " ;} #:: show results sorted by reverse creation time (long, ks kt kj km)
klr () { #:: show results sorted by reverse creation time
    local ex="$1" # additional optional k4 regex to display
    local uidlnd="$k4db/$k4_pool/uidln" ptrnxd="$k4db/$k4_pool/ptrnx"
    local xs nxp uidln ptrid
    k4db_hl '\'
    xssdaysec >$k4db/$k4_pool/tx.${FUNCNAME}.0
    # user may have invalidated the pool by deleting the directory
    knx # adds a second with pool of 200...
    ls -r "$uidlnd" | while read uidln ; do
        nxp=$(grep --files-with-matches "$uidln" "$ptrnxd"/* | head -n1 )
         printf '%- 3s ' "${nxp##*/}"
         xs="${uidln::8}"
         echo -n "$xs "
         k4db_headx '^%ks ' "$uidlnd/$uidln" | head -n1
         [ "$ex" ] && k4db_headx "$ex" "$uidlnd/$uidln" \
            | k4db_headx_filter \
            | awk -v xs="$xs" '{printf "%12s %s\n","",$0}'
        done | $k4_unlong
    k4db_hl '/'
    xssdaysec >$k4db/$k4_pool/tx.${FUNCNAME}.1
    {
      k4db_linkcount ": $FUNCNAME $@ {sort -r xs} : "
      k4db_xss_ddiff $k4db/$k4_pool/tx.${FUNCNAME} seconds ;} | $k4_unlong
    } # krl

ktl () { kt "^%k(m|t|j) " ;} #:: show results sorted by modification time (long, ks kt kj km)
kt () { #:: show results sorted by modification time
    local ex="$1" # additional optional k4 regex to display
    local xs nxp uidln uidlnd="$k4db/$k4_pool/uidln" ptrnxd="$k4db/$k4_pool/ptrnx"
    k4db_hl '\'
    xssdaysec >$k4db/$k4_pool/tx.${FUNCNAME}.0
    # user may have invalidated the pool by deleting the directory
    knx # adds a second with pool of 200...
    ##ps ls uid @ grep nx ; echo nx xs %ks
    ls -rt "$uidlnd" | while read uidln ; do
        nxp=$(grep --files-with-matches "$uidln" "$ptrnxd"/* | head -n1 )
        xs="${uidln::8}"
        printf '%- 3s %s ' "${nxp##*/}" "$xs"
        k4db_headx '^%ks ' "$uidlnd/$uidln" | head -n1
         [ "$ex" ] && k4db_headx "$ex" "$uidlnd/$uidln" \
            | k4db_headx_filter \
            | awk -v xs="$xs" '{printf "%12s %s\n","",$0}'
        done | $k4_unlong
    k4db_hl '/'
    xssdaysec >$k4db/$k4_pool/tx.${FUNCNAME}.1
    {
      k4db_linkcount ": $FUNCNAME $@ {sort mod} : "
      k4db_xss_ddiff $k4db/$k4_pool/tx.${FUNCNAME} seconds ;} | $k4_unlong
    } # kt

ktrl () { ktr "^%k(m|t|j) " ;} #:: show results sorted by reverse modification time (long, ks kt kj km)
ktr () { #:: show results sorted by reverse modification time
    local ex="$1" # additional optional k4 regex to display
    local xs nxp uidln uidlnd="$k4db/3/c/0/uidln" ptrnxd="$k4db/3/c/0/ptrnx"
    k4db_hl '\'
    xssdaysec >$k4db/$k4_pool/tx.${FUNCNAME}.0
    # user may have invalidated the pool by deleting the directory
    knx # adds a second with pool of 200...
    ls -t "$uidlnd" | while read uidln ; do
        nxp=$(grep --files-with-matches "$uidln" "$ptrnxd"/* | head -n1 )
         printf '%- 3s ' "${nxp##*/}"
         xs="${uidln::8}"
         echo -n "$xs "
         k4db_headx '^%ks ' "$uidlnd/$uidln" | head -n1
         [ "$ex" ] && k4db_headx "$ex" "$uidlnd/$uidln" \
            | k4db_headx_filter \
            | awk -v xs="$xs" '{printf "%12s %s\n","",$0}'
        done | $k4_unlong
    k4db_hl '/'
    xssdaysec >$k4db/$k4_pool/tx.${FUNCNAME}.1
    {
      k4db_linkcount ": $FUNCNAME $@ {sort -r mod} : "
      k4db_xss_ddiff $k4db/$k4_pool/tx.${FUNCNAME} seconds ;} | $k4_unlong
    } # ktr

kvl () { #:o remove from ^pool no ^%k(s|m|t|j) grep -E args
    k4_search='^%k(s|m|t|j) ' kv $@
    } # kvl
kvm () { #:o remove from ^pool no ^%km grep -E args
    k4_search='^%km ' kv $@
    } # kvm
kvs () { #:o remove from ^pool no ^%ks grep -E args
    k4_search='^%ks ' kv $@
    } # kvs
kvt () { #:o remove from ^pool no ^%kt grep -E args
    k4_search='^%kt ' kv $@
    } # kvt
kv () { #:o remove from ^pool no k4_search grep -E args
    k4db_valid_cmd || chkerr "$FUNCNAME : fail k4db_valid_cmd bc73b10 " || return 1
    local uidln uid
    local filter="$(k4_wrapregex $@)"
    xssdaysec >$k4db/$k4_pool/tx.${FUNCNAME}.0
    find $k4db/$k4_pool/uidln -type f \
        | while read uidln ; do
            awk 'NR==1,/^%kz/' "$uidln" \
                | grep -E "${k4_search}" \
                | grep $case -qE "$filter" \
                && {
                    uid="${uidln##*/}"
                    find "$k4db/$k4_pool/ptrnx" -type f -exec grep -q "$uid" \{\} \; -delete
                    rm -f "$uidln" "$k4db/$k4_pool/ptrid/$uid"
                    }
        done
    knx
    xssdaysec >$k4db/$k4_pool/tx.${FUNCNAME}.1
    {
    k4db_linkcount ": $FUNCNAME ${case} ${filter} : "
    k4db_xss_ddiff $k4db/$k4_pool/tx.${FUNCNAME} seconds ;} | $k4_unlong
    } # kg

kgl () { #:o remove from ^pool no ^%k(s|m|t|j) grep -E args
    k4_search='^%k(s|m|t|j) ' kg $@
    } # kgl
kgm () { #:o remove from ^pool no ^%km grep -E args
    k4_search='^%km ' kg $@
    } # kgm
kgs () { #:o remove from ^pool no ^%ks grep -E args
    k4_search='^%ks ' kg $@
    } # kgs
kgt () { #:o remove from ^pool no ^%kt grep -E args
    k4_search='^%kt ' kg $@
    } # kgt
kg () { #:o remove from ^pool no k4_search grep arg1
    k4db_valid_cmd || chkerr "$FUNCNAME : fail k4db_valid_cmd bc73b10 " || return 1
    local uidln uid
    local filter="$(k4_wrapregex $@)"
    xssdaysec >$k4db/$k4_pool/tx.${FUNCNAME}.0
    find $k4db/$k4_pool/uidln -type f \
        | while read uidln ; do
            awk 'NR==1,/^%kz/' "$uidln" \
                | grep -E "${k4_search}" \
                | grep $case -qE "$filter" \
                || {
                    uid="${uidln##*/}"
                    find "$k4db/$k4_pool/ptrnx" -type f -exec grep -q "$uid" \{\} \; -delete
                    rm -f "$uidln" "$k4db/$k4_pool/ptrid/$uid"
                    }
        done
    knx
    xssdaysec >$k4db/$k4_pool/tx.${FUNCNAME}.1
    {
    k4db_linkcount ": $FUNCNAME ${case} ${filter} : "
    k4db_xss_ddiff $k4db/$k4_pool/tx.${FUNCNAME} seconds ;} | $k4_unlong
    } # kg

k4_wrapregex () { #:> Transform args into extended regex, (arg1|arg2|arg3|...)
    local m="$1"
    local n="$2"
    [ "$m" ] || return 0
    [ "$n" ] && { shift ; shift ; $FUNCNAME "$m|$n" $@ ;} || echo "($m)"
    } # k4_wrapregex

kjq () { #:o background quiet search
    kj $@ >/dev/null & }
kj () { #:o pool k4 $since k4db $k4_search regex (arg1), frame display nx xs ks
    [ "$*" ] || { k4_help ; return 1 ;}
    $k4db_logstd "begin : since='$since' $FUNCNAME '$*'"
    local k4 n nx k4_more_match_cap arg="$*"
    k4db_valid_cmd || return 1
    n="$(knx_count d)"
    k4_new_match_cap=$(( n + k4_match_cap))
    [ "$n" ] || n=0
    xssdaysec | tee $k4db/$k4_pool/tx.${FUNCNAME}.0
    k4db_hl '\'
    k4db_fk4 | while read k4 ; do # @@ maybe opportunity for better performance...
        awk 'NR==1,/^%kz/' "$k4" \
            | grep -E "${k4_search}" \
            | grep "$case" -qE "$arg" && { set $(k4kl "$k4")
                n=$(( n + 1 ))
                nx=$(printf "%o" "$n")
                k4db_mknxln "$nx" "$k4"
                k4db_headx '^%ks ' "$k4" \
                  | awk -v nx=$nx -v xs=$2 'NR==1 {printf "%3s %s %s\n",nx,xs,$0}'
            [ $n -lt $k4_new_match_cap ] || return 0 ;}
        done | $k4_unlong # k4
    k4db_hl '/'
    xssdaysec >$k4db/$k4_pool/tx.${FUNCNAME}.1
    {
      k4db_linkcount ": since='${since}' $FUNCNAME $arg : "
      k4db_xss_ddiff "$k4db/$k4_pool/tx.${FUNCNAME}" seconds ;} | $k4_unlong
    $k4db_logstd "end : since='$since' $FUNCNAME $arg"
    } # kj


k_ ()  { #: Match k4 modify since arg1 days (default 3)
    local day="$1" since
    [ "$day" ] || day=3
    since="-mtime -${day}" kj .
    }
k__ ()  { #: Match k4 modify since arg1 minutes (default 90)
    local min="$1" since
    [ "$min" ] || min=90
    since="-mmin -${min}" kj .
    }

# one day = 1440 min or 86400 seconds

krst () { #:o reset uidln ptrid ptrnx in $k4db/$k4_pool
    k4db_valid_cmd || return 1
    find "$k4db/$k4_pool/ptrnx" -regex '.*/ptrnx/[[:xdigit:]]*$'      -delete
    find "$k4db/$k4_pool/ptrid" -regex '.*/ptrid/[[:xdigit:]]\{16\}$' -delete
    find "$k4db/$k4_pool/uidln" -regex '.*/uidln/[[:xdigit:]]\{16\}$' -delete
    [ "$@" ] && kj $@
    } # krst

knx () { #:> make ptrnx/ and uidln/ from ptrid/
    local ptridc k4
    k4db_valid_cmd || chkerr "$FUNCNAME : fail k4db_valid_cmd bc72c38" || return 1
    find "$k4db/$k4_pool/ptrnx" -regex '.*/ptrnx/[[:xdigit:]]*$'      -delete
    find "$k4db/$k4_pool/uidln" -regex '.*/uidln/[[:xdigit:]]\{16\}$' -delete
    find "$k4db/$k4_pool/ptrid" -regex '.*/ptrid/[[:xdigit:]]\{16\}$' -type f \
       | awk '{printf "%o %s\n",NR,$1}' \
         | while read ptridc ; do
            set $ptridc
            k4="$(head -n1 $2)"
            [ -e "$k4" ] && {
                ln "$2"  "$k4db/$k4_pool/ptrnx/$1"
                ln "$k4" "$k4db/$k4_pool/uidln/${2##*/}"
                }  || rm -f "$2"
            done
    } # knx

k4db_mknxln () { #:> update uidln/ ptrnx/ and ptrid/ given nx and k4 (arg1 arg2)
    local nx="$1" k4="$2"
    [ "$nx" ] || { chkerr "$FUNCNAME \$nx is null {5bachual} " ; return 1 ;}
    [ -f "$k4" ] || { chkerr "$FUNCNAME \$k4 is not a regular file {5bacnoun}" ; return 1 ;}
    set $(k4db_headx '^%km ' "$k4" | head -n1 | sed 's/_/ /g')
    # %km 5bbeec 5bbeec8a  33f7df04 idoent 20181010 23:24:00:Wed:1539239040
    ln -f "$k4" "$k4db/$k4_pool/uidln/$3$4"
    { echo "$k4" ; echo "$3$4" ;} >"$k4db/$k4_pool/ptrnx/$nx"
    ln -f "$k4db/$k4_pool/ptrnx/$nx" "$k4db/$k4_pool/ptrid/$3$4"
    } # k4db_mknxln

knx_count () { # count ptrnx (base arg1 [o|d|x], default x)
    k4db_valid_cmd || return 1
    local base="$1"
    [ "$base" ] || base="x"
    [ "$base" = "o" -o "$base" = "d" -o "$base" = "x" ] \
        || chkerr "$FUNCNAME : invalid base arg1=(|o|d|x): $base : bc1098ca" || return 1
    find "$k4db/$k4_pool/ptrnx" -not -name 0 -regex '.*/ptrnx/[[:xdigit:]]*$' \
        | awk 'END{printf "%'$base'\n",NR}' 
    } # knx_count @@

k4db_linkcount () { #:> report epic, ptrnx count, (current) k4_match_cap, and uidln count
    local ptrnxc="$(find "$k4db/$k4_pool/ptrnx" -type f | awk 'END{printf NR}' )"
    local uidlnc="$(find "$k4db/$k4_pool/uidln" -type f | awk 'END{printf NR}' )"
    printf "% 3s/%s/%s %s" "$ptrnxc" "$k4_match_cap" "$uidlnc" "$*"
    [ $ptrnxc -eq 0 ] && chkwrn "null match"
    [ $ptrnxc -ge $k4_match_cap ] && chkwrn "k4_match_cap overflow"
    } # k4db_linkcount @@

k4db_xss_ddiff () { #:> subtract {arg1}.1 from {arg1}.0 (per "xssdaysec >{arg1}.0"), output decimal diff, pass remaining args
    local v t0="${1}.0" t1="${1}.1"
    [ -e "$t0" -a -e "$t1" ] || { chkerr "$FUNCNAME $1 : Invalid input $t0 $t1 bc4dcae" ; return 1 ;}
    shift
    local pass="$*"
    set $(sed -e 's/_/ /' "$t1" "$t0" \
        | awk '{print  $1,$2}' | tr ' ' '\n' \
        | while read v ; do printf '%d\n' "0x$v" ; done \
        | tr '\n' ' ')
    # subseconds are 60ths in 0x, the constant converts to decimal
    dc -e "4k $1 $3 - $2 $4 - 1006632959 / + n"
    echo -n " $pass" ;} # k4db_xss_ddiff

ks () { #:o create a new k4 with subject {args} and edit
    local invoke="$FUNCNAME $*"
    $k4db_logstd "begin $$ : $invoke"
    local ks="$*"
    set $(k4db_gk "$ks")
    # /.../dot4/5/b/d/1/27bb_23f085fc_ _5bd1.kdb 5bd1 5bd127bb _23f085fc pole 20181024 19:17:21:Wed:1540433841
    export k4="$1/$2"
    $EDITOR "$k4"
    k4db_mknxln "0" "$k4"
    k4db_mknxln "$(echo $(( $(knx_count d) +1 )) | awk '{printf "%o\n",$1}')" "$k4" # emulate kj, create new search result in pool
    ci -m"(by $FUNCNAME)" -l -t-kdb -q "$k4" # init RCS
    kwds <"$k4" >"${k4}.kwd" & # background create kwd file
    k4_post "$k4"
    $k4db_logstd "end $$ : $invoke"
    } # ks

kcs () { #:o less (xss|xs|nx) default 0, with filter
    kc $@ | less ;}
kc () { #:o cat (xss|xs|nx) default 0, with filter
    $k4db_logstd "start $$ : $FUNCNAME $@"
    local k4
    set $(k4_inptr "$1")
    k4="$1"
    [ -e "$k4" ] || chkerr "$FUNCNAME no k4 $k4 (bc785a2)" || return 1
    cat "$k4" | k4db_headx_filter
    k4db_mknxln "0" "$k4"
    $k4db_logstd "end $$ : $FUNCNAME $@"
    } # kc

kxl () { #:: show results as extracted links
    local uidln="$1" uidlnd="$k4db/3/c/0/uidln"
    [ "$uidln" ] && knxl "$uidln" || {
    ls "$uidlnd" | while read uidln ; do
        k4kl "${uidlnd}/${uidln}" ; echo
    done ;}
    } # kxl

knxl () { #:> use arg1; return extracted linking data
    # set %km and output "%kl $2 $3 %ks $0"
    set $(k4_inptr "$1")
    local k4="$1"
        [ -e "$k4" ] || { chkerr "$FUNCNAME k4 '$k4' does not exist (b9d464d)" ; return 1 ;}
        { awk 'NR==1,/^%kz/' <"$k4" \
            | sed  -e '/^%km\ /!d' -e 's/^%km\ //' -e 's/_/ /g' \
            | awk '{print "%kl",$2,$3}' | tr '\n' ' '
        sed  -e '/^%ks\ /!d' <"$k4" ;}
    } # kxl

k4_kl () { #> extract %kl from k4 (arg1)
    local k4="$1"
    awk 'NR==1,/^%kz/' "$k4" \
            | sed -e '/^%k(m|s) /!d' -e 's/%k//g' \
        awk 'NR==1,/^%kz/' "$k4" | sed -e '/^%km /!d' -e 's/_/ /g' \
        
    }
knks () { #:> Extract ks from arg1 (knx)
    set $(k4_inptr "$1")
    k4ks "$1" || chkerr "$FUNCNAME bad k4 '$k1' (bda5ee6)" || return 1
    }
k4ks () { #:> Extract ks from arg1 (k4)
    local k4="$1"
    [ -e "$k4" ] || { chkerr "$FUNCNAME k4 '$k4' does not exist (bda4be0)" ; return 1 ;}
    awk 'NR==1,/^%kz/' <"$k4" | sed  -e '/^%ks\ /!d' | tr '\n' ' '
    #awk 'NR==1,/^%kz/' <"$k4" | sed  -e '/^%ks\ /!d' -e 's/^%ks\ //' | tr '\n' ' ' \
    # | awk '{print "%ks ",$0}' # @@ | squeeze wht space
    }

knkl () { #:> Extract links from arg1 (knx)
    chkerr "deprecated $FUNCNAME" || return 1
    set $(k4_inptr "$1")
    k4kl "$1" || chkerr "$FUNCNAME bad k4 '$k1' (bda5f18)" || return 1
    }
k4kl () { #:> Extract links from arg1 (k4)
    local k4="$1"
    [ -e "$k4" ] || chkerr "$FUNCNAME k4 '$k4' does not exist (bda5b1e)" || return 1
    awk 'NR==1,/^%kz/' <"$k4" | sed  -e '/^%km\ /!d' -e 's/^%km\ //' -e 's/_/ /g' \
      | awk '{printf "%s %s %s ","%kl",$2,$3}'
    k4ks "$k4"  || chkerr "$FUNCNAME bad k4 '$k1' (bda5f82)" || return 1
    # @@ | squeeze wht space
    } # k4kl

k4pool_xlinks () { #:> generate kl for every nx
    chkerr "deprecated $FUNCNAME" || return 1
    local k4 ptrnx="$k4db/$k4_pool/ptrnx"
    find "$ptrnx" -type f \! -name 0 -exec awk 'NR==1 {print $1}' \{\} \; \
        | while read k4; do
            k4kl "$k4"
            done
    } # k4db_xlinks

k4_post () { #:: display metadata and file listing of k4 {arg1}
    $k4db_logstd "start $$ : $FUNCNAME $*"
    local p="$(dirname "$1")" k4="$(basename "$1")"
    ( cd "$p"
         k4db_headx '^%km ' "$p/$k4" | sed 's/_/ /g' | awk '{print $3" "}' | tr -d '\n'
         k4db_headx '^%ks ' "$p/$k4" | sed 's/^%k//'
         k4db_headx "${k4_view}" "$p/$k4" | sed -e '/^%ks /d' -e 's=^%k=         ='
         find "${PWD}" -type f      -name "$k4" \
            -exec printf "       KDB " \; -print
         find "${PWD}" -type d -mindepth 1 -maxdepth 1 \
            -exec printf "       DIR " \; -print | sort -d
 	     find "${PWD}" -type f -not -name "$k4" -not -name "x${k4},v" -maxdepth 1 \
            -exec printf "      FILE " \; -print | sort -d
         echo "      PATH $(pwd -P)/"
         k4kl "$k4" ; echo
    )
    $k4db_logstd "end $$ : $FUNCNAME $*"
    } # k4_post

# midpoint two times
# echo 0x5bbd113d 0x5bbd18aa | awk '{printf "%d %d + 2 / p\n",$1,$2}' | dc
# 1539118323
#  geo@sullen:~/dot4/f/x echo 0x5bbd113d 0x5bbd18aa | awk '{printf "%d %d + 2 / p\n",$1,$2}' | dc | awk '{printf "%x",$1}'
# 5bbd14f3 geo@sullen:~/dot4/f/x echo 0x5bbd113d 0x5bbd18aa | awk '{printf "%d %d + 2 / p\n",$1,$2}' | dc | awk '{printf "%x\n",$1}'
# 5bbd14f3
# find /Users/geo/dot4/3/c/ -regex '.*/[[:xdigit:]]\{16\}$' | sed -e 's:.*/::' -e 's/.\{8\}$//' -e 's/^/0x/' | sort -u | awk '{printf "%s %d\n",$1,$1}' | while read s ; do set $s ; echo -n "$1 " ; date -j -r $2 ; done

k4_inptr () { #:: Return k4, xss and nx, if single match, from arg1 (xss|xs|nx), default 0
    $k4db_logstd "start $$ : $FUNCNAME $*"
    local ptr="$1" nx ptrf
    local ptrid="$k4db/$k4_pool/ptrid"
    local ptrnx="$k4db/$k4_pool/ptrnx"
    [ "$ptr" ] || ptr=0
                   ptrf="$( find "$ptrid" -name "${ptr}"  -regex ".*/ptrid/[[:xdigit:]]\{16\}$" )"      # check ptrid xss
    [ "$ptrf" ] || ptrf="$( find "$ptrid" -name "${ptr}*" -regex ".*/ptrid/${ptr}[[:xdigit:]]\{8\}$" )" # check ptrid xs
    [ "$ptrf" ] || ptrf="$( find "$ptrnx" -name "${ptr}"  -regex ".*/ptrnx/[[:xdigit:]]*$" )"           # check ptrnx nx
    [ "$ptrf" ] || chkerr "No match for ${ptr} (bcfce6d)" || return 1 
    [ "$(echo "$ptrf" | awk 'END{print NR}')" = 1 ] || { chkerr "Multi match for ptr ${ptr} $FUNCNAME bug (bcf6458)" ; return 1 ;}
    nx="$(find "$ptrnx" -type f -not -name 0 -exec grep --files-with-matches "$( awk 'NR==1' "$ptrf" )" \{\} \; )"
    [ "$nx" ] || chkwrn "No nx from $ptrf (bd12e1a)" 
    [ "$(echo "$nx" | awk 'END{print NR}')" = 1 ] || { chkerr "Multi match for nx $nx $FUNCNAME bug (bd09fa5)" ; return 1 ;}
    nx="${nx##*/}"
    cat $ptrf | tr '\n' ' '
    echo $nx
    $k4db_logstd "end $$ : $FUNCNAME $*"
    } # k4_inptr

ka () { #:o aspell arg1
    $k4db_logstd "start $$ : $FUNCNAME $*"
    local k4
    set $(k4_inptr "$1")
    k4="$1"
    nx="$3"
    [ -e "$k4" ] || chkerr "invalid ptr (no $k4)" || return 1
    aspell -c "$k4"
    k4db_mknxln "0" "$k4"
    k4db_mknxln "$nx" "$k4"
    [ -e "${k4},v" ] || ci -m"(by $FUNCNAME)" -l -t-kdb -m'aspell' -q "$k4" # increment RCS, if comma-v doesn't exist
    [ "${k4}" -nt "${k4},v" ] && ci -m"(by $FUNCNAME)" -l -q "$k4" # increment RCS, if k4 revised
    [ "${k4}" -nt "${k4}.kwd" ] && kwds <"$k4" >"${k4}.kwd" & # background increment kwd if k4 revised
    k4_post "$k4"
    $k4db_logstd "end $$ : $FUNCNAME $*"
    } # ka

k4db_showpool () { #:- show all files in k4db/k4_pool
    k4db_hl '\'
    find $k4db/$k4_pool/ptrnx -type f
    k4db_hl '-'
    find $k4db/$k4_pool/ptrid -type f
    k4db_hl '-'
    find $k4db/$k4_pool/uidln -type f
    k4db_hl '/'
    }

k4db_hl () { #:> Draw a horz line width of terminal, with arg1, default "-"
    local char="$1" cols=$(tput cols)
    [ "$char" ] || char="-"
    printf "%*s" $cols '' | tr ' ' "$char"
    } # k4db_hl
k4db_fold () { #:> on terminal output, fold long lines on words
    local cols="$(tput cols)"
    [ -t 1 ] && fold -s -w $cols || cat
    } # k4db_fold
k4db_trunc () { #:> on terminal output, truncate lines to width
    local cols="$(tput cols)"
    [ -t 1 ] && awk -v cols=$((cols-1)) 'length > cols{$0=substr($0,0,cols)"_"}1' || cat
    } # k4db_trunc
    
k4db_center_pad () { #:- Center pad stdin w/arg1 (default ^)
    local char="$1" cols=$(tput cols)
    [ "$char" ] || char="-"
    sed "s/^[ ]/$char/g" 
    } #@@@
k4db_center () { #:- Center arg1 
    local cols=$(tput cols)
    [ -t 1 ] && { fmt -w "$cols" -c | sed 's/[ ]*$//' | k4db_trunc ;} || cat
    }

k () { #:o edit k4 of nx {arg1}
    $k4db_logstd "start: < since='$since' $FUNCNAME $* >"
    local ptrnxd="$k4db/$k4_pool/ptrnx"
    set $(k4_inptr "$1")
    k4="$1"
    nx="$3"
    [ -e "$k4" ] || chkerr "invalid k4 $k4 (bcf678a)" || return 1
    $EDITOR "$k4"
    k4db_mknxln "0" "$k4"
    k4db_mknxln "$nx" "$k4" # editor may write a new inode
    [ -e "${k4},v" ] || ci -m"(by $FUNCNAME)" -l -t-kdb -q "$k4" # increment RCS, if comma-v doesn't exist
    [ "${k4}" -nt "${k4},v" ] && ci  -m"(by $FUNCNAME)" -l -q "$k4" # increment RCS, if k4 revised
    [ "${k4}" -nt "${k4}.kwd" ] && kwds <"$k4" >"${k4}.kwd" & # background increment kwd if k4 revised
    k4_post "$k4"
    $k4db_logstd "end $$ : $FUNCNAME $*"
    } # k

kh () { #:: read arg1 or stdin k4 files, return knowledge list (meta data)
    set $(k4_inptr "$1") && k4_post "$1"
    } # kl

k4db_clean () { #> Clean $k4db (remove all empty directores)
    k4db_valid_cmd
    find "$k4db" -depth -type d -empty -delete
    } # k4db_clean

k4db_headx_filter () { #:> Filter out default values from k4
    sed -E -e '
        /^%kt $/d
        /^%kj motive$/d
        /^%k(l|r|p)_(%kl )5.* isbe #/d
        /^%k(l|r|p)_(%kl )5.* self #/d
        /^%k(l|r|p)_(%kl )5.* self [ ]*# (super|related)/d
        /^%k(l|r|p)_5.* self [ ]*# (super|related|linked)/d
        /^%kd_.*index.md$/d
        /^%kn/d
        ' ;} # k4db_headx_filter

# @@ break out into four functions two iterate stdin to these two with arg1, optimize arg1 performance
k4db_headx () { #> extract x {arg1} from k4s {arg2} or stdin if arg2 is null, k4 is whitespace delimited
    local ex="$1"
    shift
    local k4 k4s="$@"
    [ "$k4s" ] || k4s="$(cat)"
    echo "$k4s" | while read k4 ; do awk 'NR==1,/^%kz/' "$k4" | grep -E "$ex" ; done
    }
k4db_head () { #> dump the entire k4 metadata single file
    local k4="$1"
    [ "$k4" ] || k4="$(cat)"
    echo "$k4" | tr ' ' '\n' | sed '/^$/d' | head -n1 \
        | while read k4 ; do awk 'NR==1,/^%kz/' "$k4" | grep "^%k" ; done
    }

# clean stdin to a subset of accii table in octal
k4db_clean_ks () { chkerr "$FUNCNAME empty" ; return 1 ;}
k4db_clean_path () { chkerr "$FUNCNAME empty" ; return 1 ;}
k4db_clean_xs () { chkerr "$FUNCNAME empty" ; return 1 ;}
k4db_clean_xss () { chkerr "$FUNCNAME empty" ; return 1 ;}
k4db_clean_name () {  tr -dc '\053-\071\101-\132\137\141-\172'         ;}
#                                                                 \012\015
#                                  + .. 9   A .. Z   _   a .. z
#                       012 nl                     015 cr
#     040 sp   041  !   042  "   043  #   044  $   045  %   046  &   047  '
#     050  (   051  )   052  *   053  +   054  ,   055  -   056  .   057  /
#     060  0   061  1   062  2   063  3   064  4   065  5   066  6   067  7
#     070  8   071  9   072  :   073  ;   074  <   075  =   076  >   077  ?
#     100  @   101  A   102  B   103  C   104  D   105  E   106  F   107  G
#     110  H   111  I   112  J   113  K   114  L   115  M   116  N   117  O
#     120  P   121  Q   122  R   123  S   124  T   125  U   126  V   127  W
#     130  X   131  Y   132  Z   133  [   134  \   135  ]   136  ^   137  _
#     140  `   141  a   142  b   143  c   144  d   145  e   146  f   147  g
#     150  h   151  i   152  j   153  k   154  l   155  m   156  n   157  o
#     160  p   161  q   162  r   163  s   164  t   165  u   166  v   167  w
#     170  x   171  y   172  z   173  {   174  |   175  }   176  ~   177 del

k4stat () { #:: for arg1 (or per line stdin) return links-inode, mtime and size in 0x, and filename
    local f fs
    [ "$1" ] && fs="$1" || fs="$(cat)"
    echo "$fs" | while read f ; do
    [ -f "$f" ] && { # links inode mod sum size name
       { stat -f '%l %i %m' "$f" ; cksum "$f" ;} | tr '\n' ' ' \
         | awk '{printf "%x%07x %8x %8x % 8x ",$1,$2,$3,$4,$5}'
         echo "$f"
       } || chkerr "$FUNCNAME : not a regular file : $f"
    done
    } # k4stat

# iREST is an
# 2) ingest all RAID, to iREST-s3
# 3) indexed s3 to glacier
# 4) index s3 with ebs,
# 5) REST-s3 to Glacier
# 5) ingest new media, to indexed s3
# 6) ingest ebs, to indexed s3
#
# find -L     referenced symbol (not null)
# find -P     symbolic pointer

modifyall-headers-without-changing-stat () { #:- eg change "^%k " to "%ks " (knowledge subject)... done XXX
# find . -regex '.*/[[:xdigit:]]\{2\}/[[:xdigit:]]\{2\}/[[:xdigit:]]\{4\}/[[:xdigit:]]\{8\}/4000[[:xdigit:]]\{4\}' -exec grep -q '^%k ' \{\} \; -print | wc -l
xs=$(xs)
find "$k4h" -regex '.*/[[:xdigit:]]\{2\}/[[:xdigit:]]\{2\}/[[:xdigit:]]\{4\}/[[:xdigit:]]\{8\}/4000[[:xdigit:]]\{4\}' \
        -exec grep -q '^%k ' \{\} \; -print \
    | while read k4; do
        echo "sed 's/^%k /%ks /' $k4 >${k4}~$xs \
            && touch -r $k4 ${k4}~$xs \
            && cat ${k4}~$xs >${k4} \
            && touch -r ${k4}~$xs $k4 \
            && rm -f ${k4}~$xs"
        done
# find "$k4h" -regex '.*/[[:xdigit:]]\{2\}/[[:xdigit:]]\{2\}/[[:xdigit:]]\{4\}/[[:xdigit:]]\{8\}/4000[[:xdigit:]]\{4\}'
}

xs2tai () { #:: convert stdin 0x seconds (59dc0896) to tai64n (@4000000059dc089600000000)
    sed -e 's/^/@40000000/' -e 's/$/00000000/' ;}

xs2local () { #:: convert idtai to local time (2017-11-29 09:47:14)
    local id="$1"
    [ "$id" ] || id="$(cat)"
    echo "$id" | xs2tai | tai64nlocal | sed 's/[\.|][0]*$//'
    } # idlocal

xs2s () { #:: convert xs to decimal
    local xs="$1"
    [ "$xs" ] || xs="$(cat)"
    echo "$xs" | while read n ; do
        printf "%d\n" "0x$n"
        done
    } # idlocal

# cat 59eaab90/069a9704/40000000
# %k 59eaab90     isbe:
# %k 069a9704     part:
# %k 40000000     vers:
# %k 20171020     year:
# %k 19:05:58     time:

# idkln () { # idk link to arg(1) XXX
#   [ "${PWD##*/}" = "kdb" ] || chkwrn "not in kdb"
#   [ -n "$1" ] || chkerr "no file to link" || return 1
#   [ -e "$1" ] || chkerr "'$1' does not exist" || return 1
#   local d=$(dirname $(idkgen))
#   ln -f "$1" "$d" ;}

idktjz () { #:o generate $1/0x40m.tjz from $1 files, remove $1 files and  XXX
chkwrn "Function works but revisit procedure... noop"
return 1
#tar cjf ./59b87dcc/0fdf221c/0x40M.tjf $( find ./59b87dcc/0fdf221c -type f | sort )
  find -d "$1" -maxdepth 0 -type d                      || { chkwrn "$0 : Not directory : $1"    ; return $? ;}
  find -d "$1" -maxdepth 1 -mindepth 1 -name 40000000   || { chkwrn "$0 : Not exist $1/40000000" ; return $? ;}
# find -d "$1" -maxdepth 1 -mindepth 1 -name 0x40m.tjz  && { chkwrn "$0 : Exist $1/0x40m.tjz"    ; return $? ;}
  find -d "$1" -type d -empty -delete # remove empty dir before tar
  find -d "$1" -mindepth 1 -type f | tar cjf "$1"/0x40m.tjf -T - \
    && find -d "$1" -mindepth 1 -type f -not -name 0x40m.tjf -not -name 40000000 -delete
  find -d "$1" -mindepth 1 -type d -empty                   -delete
  head "$1"/40000000     >>"$1"/40000000
  echo    "$1"/0x40m.tjf >>"$1"/40000000
  tar tjf "$1"/0x40m.tjf >>"$1"/40000000
 }

# ds=080600002015
# date -j -v +0d $ds +%s
# 1438844400
# date -j -v +0d $ds
# Thu Aug  6 00:00:00 PDT 2015
# printf '%x\n' $(date -j -v +0d $ds +%s)
# 55c305f0
# xs=$(printf '%x\n' $(date -j -v -1d $ds +%s))
# dxs=$(printf %d "0x$xs")
# ke=1438844400 day=86400 is="6 7 9 12 14 18 23 28 43 38 57"
# dxs=$(( dxs - day ))
# for i in $is ; do
#  printf '%02d/%02d ' "$(( ( ($dxs - $ke ) % ( $i * $day ) ) / $day + 1  ))" "$i"
# done
nevernowd () { #:> %kj 59cfe7ba nevernow intervals ds=080600002015 kdb-ics-tmpl.sh
    local i
    local xs=$(xs)
    local dxs=$(printf %d "0x$xs")
    local ke=1438844400 day=86400 is="6 7 9 12 14 18 23 28 43 38 57 63 194"
    local dxs=$(( dxs - day ))
    for i in $is ; do
        printf '%02d/%02d ' "$(( ( ($dxs - $ke ) % ( $i * $day ) ) / $day + 1  ))" "$i"
    done
} # nevernowd # 01/06 01/07 01/09 07/12 01/14 01/18 08/23 15/28 17/43 33/38 52/57
nevernowx () { #:> %kj 59cfe7ba nevernow intervals ds=080600002015 kdb-ics-tmpl.sh
    local i
    local xs=$(xs)
    local dxs=$(printf %d "0x$xs")
    local ke=1438844400 day=86400 is="6 7 9 12 14 18 23 28 43 38 57 63 194"
    local dxs=$(( dxs - day ))
    for i in $is ; do
        printf '%02xx%02x ' "$(( ( ($dxs - $ke ) % ( $i * $day ) ) / $day + 1  ))" "$i"
    done
} # nevernowx # 01/06 01/07 01/09 07/12 01/14 01/18 08/23 15/28 17/43 33/38 52/57
nevernowo () { #:> %kj 59cfe7ba nevernow intervals ds=080600002015 kdb-ics-tmpl.sh
    local i
    local xs=$(xs)
    local dxs=$(printf %d "0x$xs")
    local ke=1438844400 day=86400 is="6 7 9 12 14 18 23 28 43 38 57 63 194"
    local dxs=$(( dxs - day ))
    for i in $is ; do
        printf '%02oo%02o ' "$(( ( ($dxs - $ke ) % ( $i * $day ) ) / $day + 1  ))" "$i"
    done ; echo
} # nevernowo # 01/06 01/07 01/09 07/12 01/14 01/18 08/23 15/28 17/43 33/38 52/57
# http://www.geeksforgeeks.org/convert-base-decimal-vice-versa/
# Convert from any base to decimal and vice versa
# https://phanderson.com/C/baseprnt.html
# Base Conversion


rdot4 () { #:- reverse words into dot4 space
    ptr $(echo space.dot4.$@ | tr '\t\ ' '.') | tr '.' '\ '
}

revword () { #:>> for each line read from stdin, reverse the order of words (filter ascii, delim with space)
return 1 ;} # revword
revbyte () { #:>> for each line read from stdin, reverse the order of bytes (filter \0, awk delim with \0)
return 1 ;} # revbyte
revline () { #:>> reverse the order of lines read from stdin
return 1 ;} # revline

rev () { #:> stdin/arg1 reverse bytes, ^ is reserved
    local in="${*}^" x1i x1o x2o ot
    [ "$in" = "^" ] && in="$(cat)^"
    [ -z "$(ecp "1" "$in")" ] && { ecp "2-" "$in" ; return 0 ;}
    x1a="$(ecc "2-" "$in" )"
    x1b="$(ecc "1"  "$in" )"
    x2o="$(ecp "2-" "$in" )"
    ot="${x1a}^${x1b}${x2o}"
    $FUNCNAME "$ot" ;}
ecc () { #: >> cut $1 field char from $2 and remove ptr
    echo "$2" | cut -c "$1" | sed 's/\^.*//g' ;}
ecp () { #: >> cut $1 field ptr from $2 and remove ptr
    echo "$2" | cut -d '^' -f "$1" | sed 's/\^.*//g' ;}

ptr () { #:> reverse a dotted network
rev="$(echo "$1" | cut -d\. -f1).$2" ; ip="$(echo "$1" | cut -d\. -f2-)"
[ "$ip" = "$1" ] && echo "${rev}" || ptr $ip $rev ;}
arpa () { #:> use ptr to reverse a network, and add in-addr.arpa
[ -z "$1" ] && echo -n "An ip address on the command line returns its "
echo "$(ptr "$1")in-addr.arpa" ;}

xs () { #:: tai64n seconds
    xssdaysec | k4db_np "$k4db" xyz | awk '{print $3}' ;}
    # current unix time in 0x
    # printf '%x' $(date '+%s') ;}
    # echo | tai64n | sed -e 's/^@4[0]*//' -e 's/.\{8\} $//' ;}
    # /Users/geo/dot4/5/b/a/1/3/0a2_241f46bc 5ba13 5ba130a2 _241f46bc grifi 20180918 10:06:32:1537290392 xyz

xss () { #:: tai64n seconds long
    xssdaysec | k4db_np "$k4db" xyz | awk '{print $3$4}' | sed 's/_//' ;}
    # 5bda677e28c8931c

eid () { #:> epoch identification { 5bd-ucti }
    # ...creates nothing, passes args
    xssdaysec | k4db_np $k4db | awk '{print $2"-"$5}' $* ;}

k4_epoch () { #:> return epoch according to arg1 significant digits (default 4)
    local xss="$(xss)" n="$1"
    [ "$n" ] || n=4
    echo ${xss::$n} ;} # k4_epoch

xssdaysec () { #:: no input, tai64n seconds.60s and std
    date "+%Y%m%d %H:%M:%S:%a:%s" | tai64n | sed -e "s/^@4[0]*//" -e 's/^[[:xdigit:]]\{8\}/&_/';}
    # 5b9c30d337227e8c 20180914 15:06:01:1536962761

# %kl 5bbeec8a 33f7df04 %ks isbe lean validation test narrated
vk4db_headx () { return 1 ;} #:> extract regex (arg1) from files (remaining args OR stdin), files whitespace separated, only lines preceding ^%k4z
vk4db_head () { return 1 ;}  #:> dump the entire k4 metadata single file
vk4db_km () { return 1 ;}    #:> make sure %km is parsable in all k4 files
vk4db_env () { return 1 ;}   #:> check env, error on bad settings, report non-default
        #files are k4db_fk4 | while read k4 ; do set $(k4db_headx '^%km ' "$k4" | head -n1 | sed 's/_/ /g' | grep -v Users ) ; uid=$3$4 ; echo "$k4 - ${#uid}" ; done | less
   # k4db_fk4 | while read k4 ; do set $(k4db_headx '^%km ' "$k4" | head -n1 | sed 's/_/ /g') ; echo $3$4 | sed -e '/[[:xdigit:]]\{16\}/d' ; done # should have null result

k4db_valid_cmd () { #:> Validate env and functions, lightweight foreground tests
    local cksum fail="fail"
    # -x tai64n and friends
    # -x bsd find
    # -x bsd sort
    # -x gpw
    # -x aspell
    [ "$k4db" = "/Users/geo/dot4" ] || { chkerr "$FUNCNAME : unexpected k4db : $k4db : bc02189"    ; fail="${fail} bc02189" ;}
    # echo "$k4 $nx" # XXX havoc if k4 has a space in it! bcfc825
    #
    [ "$k4_pool" = "3/c/0"  ] || { chkerr "$FUNCNAME : invalid k4_pool : $k4_pool : bbfcf27" ; fail="${fail} bbfcf27" ;}
   #[ "$k4_parm" = "3/c/1"  ] || { chkerr "$FUNCNAME : invalid k4_parm : $k4_parm : bc02910" ; fail="${fail} bc02910" ;}
    [ "$k4_hist" = "3/c/2"  ] || { chkerr "$FUNCNAME : invalid k4_hist : $k4_hist : bc029a0" ; fail="${fail} bc029a0" ;}
    #
    [ -d "$k4db/$k4_pool/ptrnx" ] || { chkerr "$FUNCNAME : not a directory k4db/k4_pool/ptrnx : $k4db/$k4_pool/ptrnx : bbfca90" ; fail="${fail} bbfca90" ;}
    [ -d "$k4db/$k4_pool/ptrid" ] || { chkerr "$FUNCNAME : not a directory k4db/k4_pool/ptrid : $k4db/$k4_pool/ptrid : bbfca91" ; fail="${fail} bbfca91" ;}
    [ -d "$k4db/$k4_pool/uidln" ] || { chkerr "$FUNCNAME : not a directory k4db/k4_pool/uidln : $k4db/$k4_pool/uidln : bbfca92" ; fail="${fail} bbfca92" ;}
    [ -x "$k4db/$k4_pool/ptrnx" -a -w "$k4db/$k4_pool/ptrnx" ] \
        || { chkerr "$FUNCNAME : invalid k4db/k4_pool/ptrnx : $k4db/$k4_pool/ptrnx : bc02c20" ; fail="${fail} bc02c20" ;}
    [ -x "$k4db/$k4_pool/ptrid" -a -w "$k4db/$k4_pool/ptrid" ] \
        || { chkerr "$FUNCNAME : invalid k4db/k4_pool/ptrid : $k4db/$k4_pool/ptrid : bc02c21" ; fail="${fail} bc02c21" ;}
    [ -x "$k4db/$k4_pool/uidln" -a -w "$k4db/$k4_pool/uidln" ] \
        || { chkerr "$FUNCNAME : invalid k4db/k4_pool/uidln : $k4db/$k4_pool/uidln : bc02c22" ; fail="${fail} bc02c22" ;}
    #
    [ -e "$k4db/$k4_pool/nulltime" ] || { chkerr "$FUNCNAME : no nulltime : $k4_nulltime : bbfd346"  ; fail="${fail} bbfd346" ;}
    [ -e "$k4db/$k4_pool/lasttime" ] || { chkerr "$FUNCNAME : no lasttime : $k4_lasttime : bbfd371"  ; fail="${fail} bbfd371" ;}
    #
    cksum="$(k4db_headx "${k4_view}" /Users/geo/dot4/5/b/b/e/e/c/8a_33f7df04_/_5bbeec.kdb | cksum)"
    [ "$cksum" = "1121735705 245" ] || { chkerr "$FUNCNAME : failed k4_view cksum  : $cksum : bbeec" ; fail="${fail} bbeec" ;}
    #
    [ "$fail" = "fail" ] && return 0 \
        || chkerr "$FUNCNAME : $fail"
    return 1
    } # k4db_valid

k4db_valid_bg () { #:> Validate state, env and functions, heavyweight background tests
    true
    } # k4db_valid_bg

k4db_init () { #:> Environment setup
    local cksum fail="fail"
    local h="$(cd ~ && pwd -P)"
    [ "$k4db" = "$h/dot4" ] || { chkerr "$FUNCNAME : unexpected k4db : $k4db : bc11a92" ; fail="${fail} bc11a92" ;}

    # XXX @@ setup sigpipe traps
    export LC_ALL="C"
    export k4_pool="3/c/0"
    export k4_hist="3/c/2"
    
    export k4db_tags="$k4db/c/etc/tags.tbl"
    export k4db_ntag="$k4db/c/etc/ntag.tbl"
    export k4db_logstd="k4db_logstd"
    
    export k4_unlong='k4db_fold'
    export k4_unlong='k4db_trunc'
    export case='-i'
    export k4_match_cap=192
    export k4_search='^%k(s|j|t|d|l|r|p|n|m)'
    export     k4_view='^%k(j|t|d|l|r|p|m)'
    export     k4_topic='^%k(s|t|j|l|r|p)'

    mkdir -p "$k4db/$k4_pool" "$k4db/$k4_hist" \
        || { chkerr "cannot create k4db/k4_pool ($k4db/$k4_pool) k4db/k4_hist ($k4db/$k4_hist) : bc3fee0"
            fail="${fail} bc3fee0" ;}
    mkdir -p "$k4db/$k4_pool/ptrnx" "$k4db/$k4_pool/ptrid" "$k4db/$k4_pool/uidln" \
        || { chkerr "cannot create k4db/k4_pool/ptrnx k4db/k4_pool/ptrid k4db/k4_pool/uidln ($k4db/$k4_pool) : bc3fef1"
            fail="${fail} bc3fef1" ;}

    touch -t 201508060000 "$k4db/$k4_pool/nulltime" \
        || { chkerr "$FUNCNAME : cannot create k4db/k4_pool/nulltime : $k4db/$k4_pool/nulltime : bc11d49"
            fail="${fail} bc11d49" ;}
    touch                 "$k4db/$k4_pool/lasttime" \
        || { chkerr "$FUNCNAME : cannot create k4db/k4_pool/lasttime : $k4db/$k4_pool/lasttime : bc11da6"
            fail="${fail} bc11da6" ;}

    [ "$fail" = "fail" ] && return 0 || chkerr "$FUNCNAME : $fail (bd1faaa)"
    } # k4db_init


k4db_init && chkwrn "k4db_init : success!" || chkerr "k4db_init : fail"

